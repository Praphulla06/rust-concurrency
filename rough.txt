use std::{
    sync::{Arc, Condvar, Mutex},
    thread,
    time::Duration,
};

const BUFFER_SIZE: usize = 5;
const ITEM_TO_PRODUCE: usize = 10;

fn main() {
    let buffer = Arc::new((
        Mutex::new(Vec::<usize>::new()),
        Condvar::new(),
        Condvar::new(),
    ));

    let producer_buffer = Arc::clone(&buffer);
    let consumer_buffer = Arc::clone(&buffer);

    let producer = thread::spawn(move || {
        for i in 0..ITEM_TO_PRODUCE {
            let (lock, wake_consumer, wake_producer) = &*producer_buffer;
            let mut buf = lock.lock().unwrap();

            while buf.len() == BUFFER_SIZE {
                buf = wake_producer.wait(buf).unwrap();
            }
            let value = i * 67;
            println!("Produced: {}", value);
            buf.push(value);

            wake_consumer.notify_one();
            drop(buf);
            thread::sleep(Duration::from_millis(200));
        }
    });

    let consumer = thread::spawn(move || {
        for _ in 0..ITEM_TO_PRODUCE {
            let (lock, wake_consumer, wake_producer) = &*consumer_buffer;

            let mut buf = lock.lock().unwrap();
            while buf.is_empty() {
                buf = wake_consumer.wait(buf).unwrap();
            }

            let item = buf.remove(0);
            println!("Consumed: {}", item);

            wake_producer.notify_one();
            drop(buf);
            thread::sleep(Duration::from_millis(400));
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
